# BScript Documentation

bscript는 간단한 트리거 제작부터 컷씬 제작까지 다양하게 활용될 수 있는 스크립트입니다.

# 사용법
오브젝트에 BScriptExecutor 컴포넌트를 부착하세요.

속성

### 고유 ID
씬 안에서 스크립트를 구분하기 위해 사용되는 고유한 ID값입니다. 새로운 BScriptExecutor가 생성되면 자동으로 랜덤하게 4자리 Hex-Digits가 부여됩니다.
가독성을 위해 고유 ID를 임의로 바꾸셔도 됩니다. 스크립트가 이전에 실행되었는지를 확인할 때 이 값이 사용됩니다.

### 스크립트 실행 반복
스크립트가 전체 게임에서 오직 한번만 실행되도록 강제할 수 있습니다.
1. `오직 한번만 실행`
스크립트가 한번 실행되었다면 다시는 실행되지 않습니다. 이는 저장 세션에 해당 스크립트의 고유 ID를 저장하는 방식으로 동작합니다.
2. `여러번 실행`
스크립트가 여러번 실행될 수 있습니다.

### 스크립트 실행 조건식
스크립트가 실행되기 위해서 무조건 참 값이 되어야 하는 조건식입니다. 조건식이 따로 정의되지 않았다면 참으로 간주됩니다. 자세한 내용은 [조건식]을 확인하세요.

### 컷씬
스크립트가 컷씬으로 실행되여야 하는지를 나타냅니다. 체크가 되어있다면 스크립트 실행부터 종료까지 게임이 컷씬 모드로 진입합니다.

### 스크립트 실행 환경
스크립트가 실행될 수 있는 환경을 설정합니다.
1. `컷씬 재생 중에는 실행 불가능`
컷씬이 재생되고 있는 중에는 스크립트가 절대 실행되지 않습니다. 단, 컷씬이 시작되지 이전에 원래 실행되고 있었던 스크립트의 실행은 컷씬이 시작되어도 종료되지 않습니다.
2. `컷씬과 함께 실행 가능`
컷씬이 실행되고 있는 도중에도 스크립트가 실행될 수 있습니다.

### 스크립트 본문
자유롭게 스크립트를 작성하시면 됩니다. 자세한 명령어는 [명령어]를 참조하세요.
스크립트가 실행되고 있다면 현재 어떤 라인이 실행되고 있는지 확인할 수 있습니다.


# 명령어

### 표기 규칙
- `<`, `>`로 감싸진 파라미터는 필수적으로 전달하여야 하는 파라미터를 나타냅니다.
- `[`, `]`로 감싸진 파라미터는 선택적으로 전달될 수 있는 파라미터를 나타냅니다.
- 파라미터의 타입이 `|`로 연결되어 있다면 복수의 타입을 처리할 수 있음을 나타냅니다.
- 파라미터의 타입 앞에 `@`가 붙어있다면 해당 컴포넌트를 가진 오브젝트의 이름을 파라미터로 넘겨줘야 합니다.
- 파라미터의 타입 뒤에 `..`가 붙어있다면 해당 파라미터와 그 뒤의 모든 파라미터를 모아서 하나의 파라미터로 받는다는 의미입니다. 이때는 따로 `"`가 필요 없습니다.

### 문법
- 항상 한 줄이 하나의 명령어에 대응됩니다.
- 각 줄은 항상 명령어의 키워드로 시작합니다.
- 파라미터의 순서는 바뀔 수 없습니다.
- 파라미터는 하나 또는 하나 이상의 공백으로 구분됩니다.
- `//`를 사용하여 주석을 사용할 수 있습니다.
- 파라미터가 공백을 포함해야 하는 경우, `"`로 감싸면 하나의 파라미터로 처리됩니다.
- 키워드와 대부분의 파라미터는 대소문자 구분을 하지 않습니다.

## SAY
> say \<캐릭터: CharacterType> \<메세지: string>

Character가 대화를 하도록 만듭니다. 대화가 플레이어에 의해 넘어갈 때까지 스크립트 실행이 중단됩니다.

## MOVE
> move \<대상: CharacterType | @Movable> \<목적지: Vector2 | @Marker> [WAIT]

CharacterType에 해당하는 캐릭터 또는 Movable 오브젝트를 목적지로 이동시킵니다.
목적지로 이동하는 속력은 미리 정의된 속력을 사용합니다. `SPEED` 명령어를 사용하여 속력을 변경할 수 있습니다. `WAIT`이 정의되었다면 대상이 목적지까지 이동할 때까지 스크립트 실행이 중단됩니다.

## SHOW
> show \<캐릭터: CharacterType> \<위치: Vector2 | @Marker>

CharacterType에 해당하는 캐릭터를 주어진 위치에 소환합니다. 이미 소환된 상태라면 위치만 변경됩니다.

## HIDE
> hide \<캐릭터: CharacterType>

CharacterType에 해당하는 캐릭터를 숨깁니다. 캐릭터 오브젝트가 제거되지 않고 숨김처리 된다는 점에 주의하세요. 나중에 다시 show를 호출할 수도 있습니다.

## WAIT
> wait \<초: float>

스크립트 실행을 주어진 시간동안 중단합니다.

## TRANSFER
> transfer \<씬 이름: string>

주어진 이름을 가진 씬으로 이동합니다. 이동하려는 씬은 씬 빌드 목록에 추가된 상태여야 합니다.

## SET
> set \<변수: VarPath> \<값: Expression..>

변수를 주어진 값으로 설정합니다.

## PLAYANIM
> playanim \<캐릭터: CharacterType> \<애니메이션 상태 이름: StateName> [재생 시간: float]

캐릭터가 주어진 애니메이션을 재생하게 합니다. 재생 시간이 주어지지 않았다면 수동으로 중지할 때 까지 계속 실행됩니다.

## STOPANIM
> stopanim \<캐릭터: CharacterType>

캐릭터가 재생하고 있는 애니메이션을 중지하고 기본 애니메이션이 실행되도록 합니다.

## SPEED
> speed \<캐릭터: CharacterType> \<속력상대값: float>

캐릭터의 속력을 조절합니다. 이 명령어는 미리 정의된 캐릭터의 속력을 절대 바꾸지 않으며 기본 속력에 상대값이 곱해지는 방식으로 동작합니다. 따라서 1이 주어진다면 기본 속력과 같아지고, 0.5, 2가 주어진다면 각각 속력이 기본 속력에 비해 0.5배, 2배가 됩니다.
 
## FADEIN
> fadein \<초: float> [WAIT]

화면을 주어진 시간동안 밝게 페이드인 시킵니다. `WAIT`이 정의되었다면 페이드인 효과가 끝날 때 까지 스크립트 실행이 중단됩니다.

## FADEOUT
> fadeout \<초: float> [WAIT]

화면을 주어진 시간동안 어둡게 페이드아웃 시킵니다. `WAIT`이 정의되었다면 페이드아웃 효과가 끝날 때 까지 스클비트 실행이 중단됩니다.

## CAMMOVE
> cammove \<목적지: Vector2 | @Marker> \<속도: Speed> [WAIT]

카메라를 목적지까지 부드럽게 이동시킵니다. 예외적으로 주어진 속도가 Instant인 경우 카메라의 위치가 목적지로 즉시 변경됩니다. 이 명령어를 사용하였다면 더 이상 카메라에 캐릭터를 따라가지 않습니다. 따라서 카메라가 다시 캐릭터를 추적하도록 하려면 [CAMADD] 명령어를 사용하세요. `WAIT`이 정의되었다면 카메라가 목적지까지 이동할 때 까지 스크립트 실행이 중단됩니다.

## CAMADD
> camadd \<캐릭터: CharacterType>

카메라가 주어진 캐릭터를 추적하도록 합니다. 추적하는 캐릭터가 두 명 이상일 경우 그들의 중점을 추적합니다. 캐릭터가 스폰되지 않았다면 무시됩니다.

## CAMDEL
> camdel \<캐릭터: CharacterType>

카메라가 주어진 캐릭터를 더 이상 추적하지 않도록 합니다. 카메라가 아무 캐릭터도 추적하지 않는 상태라면 카메라는 그 자리에서 움직이지 않습니다.

## CAMCLR
> camclr

카메라가 추적하고 있는 모든 캐릭터에 대해 추적을 중단합니다. 이 명령어가 실행된 시점에서 카메라는 더 이상 움직이지 않습니다. [CAMMOVE]또는 [CAMADD]로 다시 카메라를 움직이도록 만들 수 있습니다.

## DO
> do  
<코드>  
end

코드를 병렬적으로 실행될 수 있도록 합니다. do부터 end까지 둘러쌓인 코드는 do 바깥의 코드와 별개로 실행됩니다. 스크립트의 실행은 스크립트에 포함된 모든 DO 블럭의 실행이 끝날 때 까지 중단되지 않습니다. 즉, 메인 코드가 실행을 마쳤다고 하더라도 아직 실행이 끝나지 않은 DO 블럭이 있다면 스크립트는 종료되지 않습니다.

## Example
캐릭터 A는 P1로 이동한 뒤 P2로 이동해야 하고, 캐릭터 B는 P3로 이동한 뒤 P4로 이동해야 하는 상황을 가정해봅시다. A의 이동이 끝난 뒤에 B의 이동을 시작해야 한다면 do를 사용하지 않고 아래와 같이 스크립트를 작성할 수 있습니다.
```
move A P1 wait
move A P2 wait
move B P3 wait
move B P4 wait
```
`WAIT`이 사용된 점을 눈여겨보세요. WAIT이 사용되지 않았다면, A가 P1으로 움직이려고 하자마자 `MOVE A P2`가 실행되면서 A는 P1을 경유하지 않고 곧바로 P2로 향하게 될 것입니다.

그런데 만약 A가 P1 -> P2로 이동하는 동시에 B가 P3 -> P4로 이동해야 한다면 어떻게 해야 할까요? 4개의 라인이 순차적으로 실행되는 한 위와 같은 기능을 구현할 수 없을 것입니다. 이때 `DO`를 사용할 수 있습니다.
```
do
move A P1 wait
move A P2 wait
end
do
move B P3 wait
move B P4 wait
end
```
이렇게 하면 첫번째 DO 블럭과 두번째 DO 블럭이 병렬적으로 실행되기 때문에 저희가 원하는 기능을 구현할 수 있게 됩니다.


## IF ELIF ELSE
> if <조건식: Expression>  
<코드>  
elif <조건식: Expression>  
<코드>  
...  
else  
<코드>  
end

조건문인 if, else if, else문을 구현합니다. elif나 else는 반드시 사용하지 않아도 됩니다. 반드시 끝에 end가 위치해야 합니다.

## Example
```
if val >= 5
say bona "값이 5 이상입니다."
elif val >= 0
say bona "값이 0 이상입니다."
else
say bona "값이 음수입니다."
end
```
스토리 상으로 특정 조건이 달성되었는지 여부에 따라 동작을 달리하고 싶을 때 유용하게 사용될 수 있습니다.


# 타입

## CharacterType
`enum CharacterType`에 정의된 값을 따릅니다.

---

## Vector2
공백 없이 `x,y`와 같이 표현해야 합니다.

---

## VarPath
저장 세션에 사용되는 키 값입니다. 점(`.`)이 없이 이름만 포함되어 있다면 자동으로 `CurrentScene` 네임스페이스를 사용합니다. 즉, 현재 씬 안에서만 유효한 값입니다. 만약 다른 네임스페이스를 사용하고 싶다면, `<네임스페이스이름>.<변수이름>`과 같이 사용하면 됩니다. 이렇게 하면 현재 씬에 종속되지 않고 어떤 씬에서도 참조할 수 있게 됩니다.

---

## Expression
값을 구할 수 있는 표현식입니다. Expression에 사용될 수 있는 타입은 `null`, `bool`, `int` 또는 `long`, `float` 또는 `double`로 한정됩니다.

표현식의 결과 타입이 `bool`이라면 바로 참/거짓을 판단할 수 있지만, `bool`이 아니라면 다음과 같은 규칙에 의해 처리됩니다.

|타입|참/거짓|
|---|---|
|null|false|
|bool|값 그대로|
|int, long, float, double|0이면 false, 그 외의 경우 true|

사용할 수 있는 연산자는 다음과 같습니다. 연산자는 우선순위가 높을수록 먼저 연산되며, 우선순위가 같다면 왼쪽에서부터 오른쪽으로 연산됩니다. 괄호를 사용하여 연산 순서를 변경할 수 있습니다.
아래 표는 우선순위가 높은 순서대로 정리한 것입니다.
|연산자|기능|
|---|---|
|!|논리 부정|
|*|곰셈|
|+ -|덧셈, 뻴셈|
|< > <= >=|대소 비교|
|== !=|같음, 같지 않음|
|&& and|논리곱|
|\|\| or|논리합|

true, false로 bool 상수를 추가할 수 있으며, 123, 1.23 등으로 정수, 실수 상수를 추가할 수 있습니다. 이 외의 모든 표현은 변수로 취급됩니다.
예를 들어 다음 표현식에서
```
(1 + hello == world.name * 3) and true
```
1, 3은 각각 정수, true는 bool 상수 값으로 취급되지만, `hello`와 `world.name`은 자동으로 저장 세션에서의 값을 의미하게 됩니다. 여기서의 규칙은 [VarPath]와 동일합니다. `hello`는 현재 씬에서의 변수값, `world.name`은 네임스페이스 `world` 안의 `name`이라는 변수값을 지칭합니다.

아직까지 한번도 정의(set)되지 않은 변수는 `null`값을 가집니다.
아래와 같은 표현식도 유효합니다.
```
hello
```
`hello`라는 변수가 한번도 정의된 적이 없다면, `null`값을 가집니다. 만약 위와 같은 표현식이 if문 등에서의 논리 표현식으로 사용되었다면, 위의 표에서 서술한 규칙에 의해 `false`값으로 해석됩니다.

또한 `null`에 특정 연산을 가하려고 한다면 해석기는 자동으로 `null`값을 연산 가능한 값으로 변환하려고 시도합니다.
|null|변환하려는 타입|값|
|---|---|---|
|null|bool|false|
|null|int, long, float, double|0|

예를 들어 다음과 같은 표현식에서
```
hello + 1
```
hello가 정의되지 않은 변수여서 `null`값을 가지는 상태라면, 위 식은 `1`의 값을 가집니다. 덧셈 연산자가 `null`값을 `0`으로 해석하여 연산을 수행하였기 때문입니다. 하지만 아래와 같이 명시적으로 `null`값을 사용할 수 없습니다.
```
null + 1
```
위 식은 해석기가 `null`을 `null`값으로 이해하지 않고 현재 씬 안에서 `null`이라는 이름의 변수를 참조하는 식으로 이해합니다.

---

## StateName
애니메이션 상태(State)의 이름을 나타내는 문자열입니다. **클립의 이름이 아니라 상태의 이름을 나타낸다는 점에 유의하세요. 클립 이름과 상태 이름은 다를 수 있습니다.** 애니메이션 상태(State)의 이름은 애니메이션 컨트롤러를 열었을 때 `Animator`창에서 보여지는 이름을 의미합니다. 클립의 이름은 `Animator`창에서 특정 상태를 클릭했을 때 나타나는 프로퍼티 중 `Motion`에 연결된 `Animation Clip` 파일 이름입니다. 만약 캐릭터에 Animator 컴포넌트가 존재하고, Animator가 `앞으로 걷기`라는 이름의 상태를 포함하고 있다면 다음과 같이 애니메이션을 재생할 수 있습니다.
```
playanim bona "앞으로 걷기"
```
그러나 애니메이션 상태 이름이 자주 사용되는데 항상 위와 같이 따옴표로 감싼 긴 이름을 사용하는 것은 상당히 불편할 수 있습니다. 이 경우 `AnimationPalette` 컴포넌트를 사용하여 애니메이션 상태 이름의 별칭(Alias)을 정의할 수 있습니다.
`AnimationPalette` 컴포넌트는 `Animator` 컴포넌트와 동일한 오브젝트에 부착되어야 합니다.

만약 `AnimatorPalette`에서 `앞으로 걷기` 애니메이션 상태 이름을 `WALK_F`로 정의하였다고 가정합니다. 이제 StateName은 원래 상태 이름 뿐만 아니라 새로 정의된 별칭도 허용하게 됩니다. 따라서 `앞으로 걷기` 대신 `WALK_F`를 사용할 수 있습니다.
```
playanim bona WALK_F
```

---

## Speed
기본 속력 대비 상대적인 속력을 표현하는데 사용됩니다.
|이름|배수|
|---|---|
|INSTANT|즉시|
|FASTEST|3|
|FAST|2|
|NORMAL|1|
|SLOW|0.5|
|SLOWEST|0.33|

위 배수값은 추후 변경될 수 있습니다.